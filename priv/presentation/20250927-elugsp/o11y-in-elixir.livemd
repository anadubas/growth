<!-- livebook:{"file_entries":[{"name":"ana_dubas.png","type":"attachment"},{"name":"joao_dubas.png","type":"attachment"}]} -->

# Observabilidade em Elixir: Um Guia Pr√°tico para M√©tricas, Logs e Traces

```elixir
Mix.install([
  {:kino, "~> 0.17.0"},
  {:jason, "~> 1.4"},
  {:req, "~> 0.4"}
])
```

## Growth-App

<!-- livebook:{"attrs":"eyJhc3NpZ25fdG8iOiIiLCJjb2RlIjoiOm9rIiwiY29va2llX3NlY3JldCI6IkdST1dUSF9SRUxFQVNFX0NPT0tJRSIsImNvb2tpZV9zb3VyY2UiOiJzZWNyZXQiLCJub2RlX3NvdXJjZSI6InRleHQiLCJub2RlX3RleHQiOiJncm93dGhAMTcyLjI1LjAuMiJ9","chunks":null,"kind":"Elixir.Kino.RemoteExecutionCell","livebook_object":"smart_cell"} -->

```elixir
require Kino.RPC
node = :"growth@172.25.0.2"
Node.set_cookie(node, String.to_atom(System.fetch_env!("LB_GROWTH_RELEASE_COOKIE")))
Kino.RPC.eval_string(node, ~S":ok", file: __ENV__.file)
```

Cansado de n√£o saber o que sua aplica√ß√£o `Elixir` est√° fazendo em produ√ß√£o? Nesta palestra, vamos dar um pontap√© inicial no mundo da observabilidade de forma pr√°tica e sem complica√ß√£o. Voc√™ vai ver como o :telemetry nos ajuda a criar logs melhores, coletar m√©tricas com `PromEx` e at√© come√ßar a brincar com tracing usando `OpenTelemetry`.

## Quem somos

![](files/joao_dubas.png)

<!-- livebook:{"break_markdown":true} -->

![](files/ana_dubas.png)

## O que √© Observabilidade?

O que acontece com a sua aplica√ß√£o quando ela vai para produ√ß√£o?

### Os tr√™s pilares da observabilidade:

* **Logs**

S√£o os registros de eventos. √â o que aconteceu no sistema, em texto. Por exemplo: `Usu√°rio 123 fez login`, ou `Erro de timeout ao acessar o banco`. Os logs contam a hist√≥ria passo a passo.

* **M√©tricas**

S√£o valores num√©ricos que a gente consegue acompanhar ao longo do tempo. Quantas requisi√ß√µes por segundo, qual a lat√™ncia m√©dia, quanto de CPU a aplica√ß√£o est√° usando. Elas ajudam a ver tend√™ncias e padr√µes.

* **Traces**

J√° os traces permitem seguir o caminho de uma requisi√ß√£o. Quando um usu√°rio faz uma chamada, o trace mostra por onde ela passou: gateway ‚Üí API ‚Üí banco ‚Üí outro servi√ßo. Isso ajuda muito a achar gargalos e entender onde est√° lento.

E por que isso importa? Porque sem observabilidade acontece o cl√°ssico: a aplica√ß√£o caiu e ningu√©m sabe por qu√™. A equipe fica no escuro, testando hip√≥teses √†s cegas. Com observabilidade, a gente tem ferramentas pra diagnosticar r√°pido e resolver com confian√ßa.

### Qual a import√¢ncia da observabilidade?

Aplica√ß√µes modernas s√£o distribu√≠das, rodam em containers, escalam em v√°rios servi√ßos. Quando d√° problema, n√£o √© mais t√£o simples abrir um log no servidor e encontrar a causa.

**Benef√≠cios principais:**

*Reduz tempo de diagn√≥stico (MTTR)*

Com observabilidade, a gente identifica r√°pido o que deu errado. Sem ela, podemos gastar horas ou dias investigando.

*Melhora a confiabilidade do sistema*

Quando conseguimos ver m√©tricas de performance e erros em tempo real, detectamos falhas antes mesmo do usu√°rio perceber.

*Ajuda a tomar decis√µes t√©cnicas e de neg√≥cio*

M√©tricas n√£o servem s√≥ para incidentes. Elas ajudam a ver tend√™ncias de uso: se uma rota √© muito chamada, se precisamos de mais recursos, ou at√© se uma funcionalidade n√£o est√° sendo usada.

*Facilita a colabora√ß√£o entre times*

Com logs, m√©tricas e traces vis√≠veis para todos, o time inteiro fala a mesma l√≠ngua. Infra, backend, frontend conseguem entender o que est√° acontecendo.

Em resumo: observabilidade n√£o √© luxo. √â o que garante que a aplica√ß√£o continue saud√°vel, os usu√°rios satisfeitos e o time produtivo. Sem isso, estamos sempre correndo atr√°s do preju√≠zo.

## Instrumentando a aplica√ß√£o com Telemetry

### O que √© Telemetry?

O `Telemetry` √© uma biblioteca padr√£o no ecossistema Elixir para instrumenta√ß√£o de aplica√ß√µes. Ele permite que diferentes partes do sistema emitam eventos sobre o que est√° acontecendo internamente, sem acoplamento entre quem emite e quem consome esses eventos. Isso √© fundamental para observabilidade, pois nos permite coletar m√©tricas, logs e, futuramente, traces, de forma padronizada e eficiente.

### Por que usar Telemetry?

**Desacoplamento**

O c√≥digo de neg√≥cio n√£o precisa saber quem est√° coletando ou processando os dados.

**Performance**

Telemetry √© extremamente leve, n√£o impactando a performance da aplica√ß√£o.

**Flexibilidade**

Podemos conectar diferentes ferramentas de m√©tricas, logs ou tracing sem alterar o c√≥digo da aplica√ß√£o.

### Como instrumentar com Telemetry?

No nosso projeto, usamos principalmente o `:telemetry.span/3` para medir a dura√ß√£o de opera√ß√µes importantes, como c√°lculos de m√©tricas de crescimento. O `span` emite dois eventos: um no in√≠cio e outro no fim da opera√ß√£o, permitindo medir tempo e capturar informa√ß√µes contextuais.

<!-- livebook:{"force_markdown":true} -->

```elixir

    :telemetry.span(
      [:growth, :calculation],
      %{
        age_in_months: child.age_in_months,
        gender: child.gender,
        measure_date: child.measure_date
      },
      fn ->
        weight_result = calculate_result(weight, :weight, child)
        height_result = calculate_result(height, :height, child)
        bmi_result = calculate_result(bmi, :bmi, child)

        head_circumference_result =
          calculate_result(head_circumference, :head_circumference, child)

        result = %{
          weight_result: weight_result,
          height_result: height_result,
          head_circumference_result: head_circumference_result,
          bmi_result: bmi_result
        }

        measure = %Measure{growth | results: result}

        {measure, %{count: 1},
         %{
           age_in_months: child.age_in_months,
           gender: child.gender,
           has_bmi_result: bmi_result != "no results",
           has_head_circumference_result: head_circumference_result != "no results",
           has_height_result: height_result != "no results",
           has_weight_result: weight_result != "no results",
           measure_date: child.measure_date,
           success: true
         }}
      end
    )


```

Aqui, emitimos um evento chamado `[:growth, :calculation]`, passando dados relevantes como idade, g√™nero e sucesso da opera√ß√£o. Esses eventos podem ser consumidos por qualquer handler Telemetry, como exportadores de m√©tricas ou sistemas de logs.

**Boas pr√°ticas**

* Instrumente pontos cr√≠ticos: foque em opera√ß√µes que afetam performance ou s√£o essenciais para o neg√≥cio.
* Use nomes de eventos claros e hier√°rquicos, como `[:growth, :calculation]`.
* Sempre envie metadados √∫teis nos eventos, como identificadores, par√¢metros e resultados.

### Como ficou nosso m√≥dulo Telemetry

<!-- livebook:{"force_markdown":true} -->

```elixir
defmodule GrowthWeb.Telemetry do
  use Supervisor
  import Telemetry.Metrics
  require Logger

  def start_link(arg) do
    Supervisor.start_link(__MODULE__, arg, name: __MODULE__)
  end

  @impl true
  def init(_arg) do
    children = [
      # Telemetry poller will execute the given period measurements
      # every 10_000ms. Learn more here: https://hexdocs.pm/telemetry_metrics
      {:telemetry_poller, measurements: periodic_measurements(), period: 10_000}
      # Add reporters as children of your supervision tree.
      # {Telemetry.Metrics.ConsoleReporter, metrics: metrics()}
    ]

    # Attach a logger for all our events.
    # This is useful for development and debugging.
    :ok = attach_events()

    Supervisor.init(children, strategy: :one_for_one)
  end

  def metrics do
    [
      # Phoenix Metrics
      summary("phoenix.endpoint.start.system_time",
        unit: {:native, :millisecond}
      ),
      summary("phoenix.endpoint.stop.duration",
        unit: {:native, :millisecond}
      ),
      summary("phoenix.router_dispatch.start.system_time",
        tags: [:route],
        unit: {:native, :millisecond}
      ),
      summary("phoenix.router_dispatch.exception.duration",
        tags: [:route],
        unit: {:native, :millisecond}
      ),
      summary("phoenix.router_dispatch.stop.duration",
        tags: [:route],
        unit: {:native, :millisecond}
      ),
      summary("phoenix.socket_connected.duration",
        unit: {:native, :millisecond}
      ),
      summary("phoenix.channel_joined.duration",
        unit: {:native, :millisecond}
      ),
      summary("phoenix.channel_handled_in.duration",
        tags: [:event],
        unit: {:native, :millisecond}
      ),

      # == Growth Metrics ==

      # User Journey Events
      counter("growth.child.created.count"),
      counter("growth.measure.submitted.count"),

      # Business Logic Span Events
      summary("growth.calculation.stop.duration",
        unit: {:native, :millisecond}
      ),
      counter("growth.calculation.stop.count"),
      summary("growth.calculation.measure.stop.duration",
        # tags: [:data_type, :success],
        unit: {:native, :millisecond}
      ),
      summary("growth.reference_data.load.stop.duration",
        # tags: [:data_type, :success],
        unit: {:native, :millisecond}
      ),
      summary("growth.reference_data.chart.stop.duration",
        # tags: [:data_type, :success],
        unit: {:native, :millisecond}
      ),

      # VM Metrics
      summary("vm.memory.total", unit: {:byte, :kilobyte}),
      summary("vm.total_run_queue_lengths.total"),
      summary("vm.total_run_queue_lengths.cpu"),
      summary("vm.total_run_queue_lengths.io")
    ]
  end

  defp periodic_measurements do
    [
      # A module, function and arguments to be invoked periodically.
      # This function must call :telemetry.execute/3 and a metric must be added above.
      # {GrowthWeb, :count_users, []}
    ]
  end

  defp attach_events do
    case Application.get_env(:growth, :env) do
      :dev ->
        :telemetry.attach_many("growth-logger", all_events(), &handle_event/4, nil)

      _ ->
        :ok
    end
  end

  defp all_events do
    [
      # User Journey
      [:growth, :child, :created],
      [:growth, :measure, :submitted],
      # [:growth, :results, :viewed],
      # [:growth, :form, :reset],
      # Spans (start, stop, exception)
      [:growth, :calculation, :start],
      [:growth, :calculation, :stop],
      [:growth, :calculation, :measure, :start],
      [:growth, :calculation, :measure, :stop],
      [:growth, :reference_data, :load, :start],
      [:growth, :reference_data, :load, :stop],
      [:growth, :reference_data, :chart, :start],
      [:growth, :reference_data, :chart, :stop]
    ]
  end

  defp handle_event(event, measurements, metadata, _config) do
    Logger.info("[Telemetry] #{inspect(event)}
  Measurements: #{inspect(measurements)}
  Metadata: #{inspect(metadata)}")
  end
end

```

### O que √© o m√≥dulo GrowthWeb.Telemetry?

Ele √© o cora√ß√£o da nossa observabilidade. Ele coleta, organiza e exp√µe m√©tricas e eventos, permitindo que a gente monitore, debugue e evolua a aplica√ß√£o com confian√ßa. Instrumentar com Telemetry √© simples, eficiente e essencial.

### Como funciona?

**Supervis√£o e Polling**

O m√≥dulo inicia um supervisor que inclui um `:telemetry_poller`. Esse poller executa medi√ß√µes peri√≥dicas, como m√©tricas da VM, a cada 10 segundos.
Podemos adicionar fun√ß√µes customizadas para serem chamadas periodicamente, por exemplo, para contar usu√°rios ativos.

**Defini√ß√£o de M√©tricas**

A fun√ß√£o `metrics/0` retorna uma lista de m√©tricas que queremos coletar.
Inclu√≠mos m√©tricas do Phoenix (tempo de requisi√ß√£o, dura√ß√£o de handlers, etc.), m√©tricas de neg√≥cio (quantidade de crian√ßas criadas, medi√ß√µes submetidas, dura√ß√£o dos c√°lculos de crescimento) e m√©tricas da VM (mem√≥ria, filas de execu√ß√£o).

Exemplo:

<!-- livebook:{"force_markdown":true} -->

```elixir
summary("growth.calculation.stop.duration", unit: {:native, :millisecond})
counter("growth.child.created.count")
```

**Logs de Telemetry para Desenvolvimento**

Em ambiente de desenvolvimento, o m√≥dulo se conecta a todos os eventos relevantes usando :telemetry.attach_many/4.
O callback handle_event/4 registra no Logger todos os eventos, medi√ß√µes e metadados, facilitando o debug e a valida√ß√£o da instrumenta√ß√£o.

Exemplo de log:

<!-- livebook:{"force_markdown":true} -->

```elixir
[Telemetry] [:growth, :calculation, :stop]
Measurements: %{duration: 12345}
Metadata: %{age_in_months: 12, gender: "female", success: true}
```

**Extensibilidade**

O m√≥dulo est√° pronto para receber novos eventos e m√©tricas. Basta adicionar novas entradas em `metrics/0` ou em `all_events/0`.
Tamb√©m √© poss√≠vel adicionar exportadores, como Prometheus, para enviar essas m√©tricas para dashboards.

### Por que isso √© importante?

**Visibilidade:** Sabemos o que est√° acontecendo na aplica√ß√£o em tempo real.
**Diagn√≥stico:** Identificamos gargalos, lentid√£o e erros rapidamente.
**Evolu√ß√£o:** Podemos tomar decis√µes baseadas em dados, n√£o em achismos.

### Boas pr√°ticas demonstradas

**Separa√ß√£o de m√©tricas de neg√≥cio e t√©cnicas:** M√©tricas de dom√≠nio (ex: c√°lculos de crescimento) e de infraestrutura (ex: mem√≥ria da VM).
**Logs estruturados e ricos em contexto:** Facilitam a an√°lise e a correla√ß√£o de eventos.
**Facilidade de extens√£o:** O m√≥dulo √© facilmente adapt√°vel para novas necessidades de observabilidade.

## Instrumentar logs, m√©tricas e traces

### Logs

*O que s√£o:* registros de eventos que aconteceram no sistema, geralmente em texto.

*Para que servem:* ajudam a entender o que aconteceu e quando aconteceu.

Exemplo:

```
"Usu√°rio 123 fez login com sucesso"

"Erro: timeout ao conectar no banco"
```

*Analogia:* um di√°rio ‚Äî cada p√°gina conta algo que ocorreu.

### M√©tricas

*O que s√£o:* valores num√©ricos que mostram como o sistema se comporta ao longo do tempo.

*Para que servem:* permitem ver tend√™ncias, padr√µes e comparar per√≠odos.

Exemplo:

```
200 requisi√ß√µes por segundo
95% das requisi√ß√µes respondem em menos de 100 ms
30% de CPU em uso
```

*Analogia:* os sinais vitais do paciente ‚Äî batimento, press√£o, temperatura.

### Traces

*O que s√£o:* registros detalhados do caminho que uma requisi√ß√£o percorre dentro do sistema.

*Para que servem:* mostram onde est√° lento, onde ocorreu erro e como servi√ßos diferentes interagem.

Exemplo:

```
Usu√°rio chama /checkout
Passa pelo API Gateway ‚Üí Servi√ßo de Pagamento ‚Üí Banco de Dados
Cada etapa tem dura√ß√£o e status registrados
```

*Analogia:* um mapa com o trajeto completo que a requisi√ß√£o fez.

## Observabilidade na Pr√°tica: Logs, M√©tricas e Traces com Elixir, OpenTelemetry e SigNoz

Adotamos uma arquitetura moderna baseada em OpenTelemetry e SigNoz, uma plataforma open-source para visualiza√ß√£o e an√°lise de logs, m√©tricas e traces.

### Arquitetura Geral

Nossa stack √© composta por:

*growth-app:* aplica√ß√£o Elixir/Phoenix instrumentada com Telemetry e OpenTelemetry.

*Logspout:* coleta logs dos containers Docker.

*OpenTelemetry Collector:* recebe, processa e exporta logs, m√©tricas e traces.

*ClickHouse:* banco de dados columnar de alta performance para armazenar todos os dados de observabilidade.

*SigNoz:* interface web para explorar, criar dashboards, alertas e analisar todos os dados.

### Fluxo dos dados:

A aplica√ß√£o envia logs, m√©tricas e traces para o Otel Collector. O Collector armazena tudo no ClickHouse. O SigNoz consulta o ClickHouse e exibe dashboards e gr√°ficos.

<!-- livebook:{"break_markdown":true} -->

<!-- Learn more at https://mermaid-js.github.io/mermaid -->

```mermaid
flowchart TD
    subgraph Docker Host
        subgraph growth-app [growth-app container]
            direction LR
            app([Application])
        end

        subgraph Observability Stack
            direction LR
            logspout[Logspout] -->|http| otel_collector
            otel_collector(OpenTelemetry Collector)
            signoz[SigNoz UI]
            clickhouse[(ClickHouse)]
        end
    end

    app -- OTLP --> otel_collector
    otel_collector -- ClickHouse Exporter --> clickhouse
    signoz -- queries --> clickhouse

    style growth-app fill:#fff,stroke:#333,stroke-width:2px
    style Observability Stack fill:#f9f9f9,stroke:#333,stroke-width:2px
```

<!-- livebook:{"break_markdown":true} -->

### Observabilidade na Aplica√ß√£o Growth

#### Logs

**Como funciona:**

Utilizamos o Logger nativo do Elixir para registrar eventos importantes da aplica√ß√£o. Al√©m disso, implementamos a biblioteca `logger_json` para criar logs estruturados, que permite a correla√ß√£o eficiente de logs com traces e m√©tricas.

`Logger JSON ({:logger_json, "~> 7.0.0"})`

**Por que usar?**

O *Logger JSON* transforma logs n√£o estruturados em formato JSON estruturado, essencial para:
*Logs Estruturados*: Facilita parsing e an√°lise automatizada
*Correla√ß√£o de Dados*: Permite correlacionar logs com traces e m√©tricas
*Busca Eficiente*: Logs JSON s√£o mais f√°ceis de indexar e pesquisar
*Integra√ß√£o com Ferramentas*: Compat√≠vel com stacks de observabilidade modernas
*Metadados Ricos*: Preserva contexto importante como request_id, user_id, etc.

**Como √© usado na aplica√ß√£o?**

Configura√ß√£o Global (`config/runtime.exs:23`):

<!-- livebook:{"force_markdown":true} -->

```elixir
config :logger, :default_handler, 
  formatter: LoggerJSON.Formatters.Basic.new(metadata: :all)
```

**Pipeline de Processamento:**

* Logs da aplica√ß√£o s√£o automaticamente formatados em JSON
* Incluem metadados como timestamps, n√≠veis, request_id
* Capturados pelo Logspout e enviados ao OpenTelemetry Collector
* O Logspout captura esses logs dos containers e envia para o OTel Collector via syslog
* O Collector armazena os logs na tabela signoz_logs do ClickHouse

`Fluxo: Application Logs (JSON) ‚Üí Logspout ‚Üí OpenTelemetry Collector ‚Üí ClickHouse ‚Üí SigNoz`

**Na pr√°tica:**

Todos os logs ficam centralizados e podem ser buscados e filtrados na interface do SigNoz. Isso facilita identificar erros, analisar fluxos e auditar o sistema. Os logs estruturados facilitam o troubleshooting e a correla√ß√£o com os demais dados de telemetria.

#### M√©tricas

**Como funciona:**

O OpenTelemetry Collector coleta m√©tricas de duas formas:

1. Scrape do endpoint /metrics exposto pela aplica√ß√£o (formato Prometheus)
2. Recebimento via OTLP diretamente da aplica√ß√£o instrumentada

As m√©tricas s√£o armazenadas na tabela signoz_metrics do ClickHouse.

`PromEx ({:prom_ex, "~> 1.11.0"})`

**Por que usar?**

O *PromEx* √© uma biblioteca Elixir que facilita a coleta e exposi√ß√£o de m√©tricas no formato Prometheus, proporcionando observabilidade completa da aplica√ß√£o Phoenix:

* *Monitoramento de Performance*: Coleta automaticamente m√©tricas de lat√™ncia, throughput e taxa de erro
* *Visibilidade da Aplica√ß√£o*: Monitora recursos do sistema como CPU, mem√≥ria e processos Erlang/Elixir
* *Detec√ß√£o Proativa de Problemas*: Permite identificar gargalos e anomalias antes que afetem os usu√°rios
* *Dashboards Automatizados*: Integra-se com Grafana para visualiza√ß√µes prontas

**Como √© usado na aplica√ß√£o?**

Configura√ß√£o no Application Tree (`lib/growth/application.ex:15`):

<!-- livebook:{"force_markdown":true} -->

```elixir
children = [
  Growth.PromEx,  # Iniciado como um dos primeiros processos
  # ... outros processos
]
```

M√≥dulo PromEx Customizado (`lib/growth/prom_ex.ex`):

*Plugins Habilitados*:

* `Plugins.Application`: M√©tricas da aplica√ß√£o OTP
* `Plugins.Beam`: M√©tricas da VM Erlang (garbage collection, schedulers)
* `Plugins.Phoenix`: M√©tricas HTTP (requests, responses, lat√™ncia)
* `Plugins.PhoenixLiveView`: M√©tricas espec√≠ficas do LiveView

Exposi√ß√£o de M√©tricas (`lib/growth_web/endpoint.ex:41`):

`plug PromEx.Plug, prom_ex_module: Growth.PromEx`

Exp√µe endpoint `/metrics` para scraping do Prometheus

Configurado para ser coletado a cada 5 segundos pelo OpenTelemetry Collector

**Na pr√°tica:**

Monitoramos contadores, histogramas de dura√ß√£o, uso de recursos, etc. No SigNoz, criamos dashboards para acompanhar sa√∫de, performance e uso do sistema. Podemos configurar alertas para anomalias ou quedas de performance

#### Traces

**Como funciona:**

A aplica√ß√£o Elixir envia traces via `OTLP` (gRPC ou HTTP) para o `OpenTelemetry Collector`. Cada trace representa o caminho de uma requisi√ß√£o ou opera√ß√£o importante, com spans detalhando cada etapa. Os traces s√£o armazenados na tabela `signoz_traces` do ClickHouse.

*Bibliotecas OpenTelemetry:*

`OpenTelemetry Core ({:opentelemetry, "~> 1.6.0"} e {:opentelemetry_api, "~> 1.4.0"})`

**Por que usar?**

O *OpenTelemetry* √© o padr√£o da ind√∫stria para observabilidade, fornecendo:

* Padroniza√ß√£o: Protocolo universal para telemetria (logs, m√©tricas, traces)
* Vendor Agnostic: N√£o fica preso a uma ferramenta espec√≠fica de observabilidade
* Distributed Tracing: Rastreamento de requisi√ß√µes atrav√©s de m√∫ltiplos servi√ßos
* Correla√ß√£o Autom√°tica: Liga automaticamente logs, m√©tricas e traces
* Instrumenta√ß√£o Autom√°tica: Coleta dados sem modificar c√≥digo de neg√≥cio

`OpenTelemetry Bandit ({:opentelemetry_bandit, "~> 0.3.0"})`

Instrumenta automaticamente o servidor HTTP Bandit (usado pelo Phoenix), coletando:

* M√©tricas HTTP: Lat√™ncia, status codes, throughput
* Traces de Requisi√ß√µes: Rastreamento completo de cada request
* Contexto de Propaga√ß√£o: Mant√©m trace context entre servi√ßos

`OpenTelemetry Phoenix ({:opentelemetry_phoenix, "~> 2.0.0"})`

Instrumenta especificamente o framework Phoenix, capturando:

* Controller Actions: Tempo de execu√ß√£o de cada action
* Pipeline Plugs: Performance de cada plug no pipeline
* LiveView Events: Instrumenta√ß√£o de eventos do LiveView
* Template Rendering: Tempo de renderiza√ß√£o de templates

`OpenTelemetry Telemetry ({:opentelemetry_telemetry, "~> 1.1.0"})`

Faz a ponte entre o sistema de Telemetry do Elixir e o OpenTelemetry:

* Convers√£o Autom√°tica: Transforma eventos Telemetry em spans OpenTelemetry
* Instrumenta√ß√£o Nativa: Aproveita a instrumenta√ß√£o j√° existente no ecossistema Elixir
* Contexto Distribu√≠do: Propaga trace context atrav√©s de processos Elixir

`OpenTelemetry Exporter ({:opentelemetry_exporter, "~> 1.9.0"})`

Respons√°vel por enviar os dados coletados para sistemas externos:

* Protocolo OTLP: Envia traces via protocolo OpenTelemetry padr√£o
* Batching: Agrupa dados para envio eficiente
* Retry Logic: Reenvio autom√°tico em caso de falhas
* Compress√£o: Reduz bandwidth com compress√£o gzip

**Na pr√°tica:**

No `SigNoz`, visualizamos o fluxo completo de requisi√ß√µes, identificando gargalos e depend√™ncias. √â poss√≠vel correlacionar traces com logs e m√©tricas para diagn√≥stico r√°pido de problemas.

### Fluxo Completo de Observabilidade

**Arquitetura:**
`Application ‚Üí OpenTelemetry SDK ‚Üí OTLP Exporter ‚Üí OTel Collector ‚Üí ClickHouse ‚Üí SigNoz`

**Sinergia das Bibliotecas:**

As bibliotecas trabalham em conjunto para fornecer os tr√™s pilares da observabilidade:

*M√©tricas (PromEx)*: "O que est√° acontecendo?"

*Logs (Logger JSON)*: "Por que est√° acontecendo?"

*Traces (OpenTelemetry)*: "Onde est√° acontecendo?"

**Benef√≠cios da Stack Completa:**

* *Observabilidade 360¬∞*: M√©tricas + Logs + Traces correlacionados
* *Troubleshooting Eficiente*: Correla√ß√£o autom√°tica entre os tr√™s pilares
* *Performance Insights*: Identifica√ß√£o precisa de gargalos
* *Alertas Inteligentes*: Baseados em dados estruturados e correlacionados
* *Vendor Independence*: Pode migrar entre ferramentas sem reescrever instrumenta√ß√£o

### Conclus√£o

Com essa arquitetura, temos observabilidade de ponta a ponta: `logs`, `m√©tricas` e `traces`
centralizados, acess√≠veis e correlacionados.

Isso nos permite:

* Detectar problemas rapidamente
* Entender o comportamento do sistema
* Evoluir com seguran√ßa e confian√ßa

O uso de ferramentas open-source como *OpenTelemetry*, *ClickHouse* e *SigNoz* torna a solu√ß√£o acess√≠vel, flex√≠vel e escal√°vel, proporcionando uma base s√≥lida para manter aplica√ß√µes resilientes e perform√°ticas em produ√ß√£o.

## SigNoz

### O que √©

O SigNoz √© uma plataforma open source de observabilidade. Ele junta os tr√™s pilares ‚Äî logs, m√©tricas e traces ‚Äî em um √∫nico lugar, compat√≠vel com o padr√£o OpenTelemetry.

### Como funciona

* Ele coleta dados enviados pela aplica√ß√£o via OpenTelemetry.

* Esses dados s√£o armazenados e processados (normalmente com ClickHouse por baixo).

* A interface web permite:

  * Criar dashboards de m√©tricas

  * Consultar logs estruturados

  * Explorar traces distribu√≠dos

### Por que usar

*Open source e gratuito* ‚Äì sem custo por host/volume de dados como nas solu√ß√µes cloud.

*Controle total* ‚Äì os dados ficam na sua infra.

*Integra√ß√£o simples* ‚Äì j√° entende OpenTelemetry, ent√£o funciona com Elixir, Node, Go, etc.

*Compar√°vel a players grandes* ‚Äì traz a mesma experi√™ncia de ferramentas comerciais

```elixir

```

## O que aprendemos

1. **Observabilidade √© essencial, n√£o opcional**

Ter logs, m√©tricas e traces centralizados nos permite entender o comportamento real da aplica√ß√£o em produ√ß√£o.

Problemas que seriam dif√≠ceis de diagnosticar (como lentid√£o, erros intermitentes ou picos de uso) ficam evidentes com poucos cliques no dashboard.

1. **Arquitetura desacoplada facilita evolu√ß√£o**

Separar a coleta (aplica√ß√£o), processamento (otel-collector) e visualiza√ß√£o (SigNoz) permite trocar ou evoluir cada parte sem grandes impactos.

O padr√£o OpenTelemetry nos d√° liberdade para integrar com outras ferramentas no futuro, sem lock-in.

1. **Instrumenta√ß√£o no c√≥digo √© simples e poderosa**

Com Telemetry no Elixir, instrumentar pontos cr√≠ticos do c√≥digo √© f√°cil e n√£o polui a l√≥gica de neg√≥cio.

Emitir eventos, m√©tricas e traces se torna parte natural do desenvolvimento.

1. **Visualiza√ß√£o e an√°lise aceleram o ciclo de feedback**

Dashboards e alertas no SigNoz permitem agir rapidamente diante de anomalias.

Conseguimos identificar gargalos, monitorar uso de recursos e entender o fluxo das requisi√ß√µes em tempo real.

1. **Logs, m√©tricas e traces se complementam**

Logs mostram o detalhe do que aconteceu.

M√©tricas mostram tend√™ncias e alertam para mudan√ßas de comportamento.

Traces mostram o caminho completo de cada requisi√ß√£o, facilitando encontrar a causa raiz de problemas.

1. **Observabilidade √© para todos**

A stack √© open-source, acess√≠vel e pode ser usada tanto em ambientes locais quanto em produ√ß√£o.

N√£o √© preciso depender de solu√ß√µes propriet√°rias caras para ter visibilidade de ponta a ponta.

1. **Cultura de melhoria cont√≠nua**

Com dados em m√£os, a equipe pode tomar decis√µes baseadas em fatos, priorizar melhorias e evoluir o sistema com confian√ßa.

Observabilidade n√£o √© s√≥ tecnologia, mas parte da cultura de desenvolvimento moderno.

## Observando a Growth

```elixir
public_url = "https://crescer.dubas.dev"
internal_url = "http://172.25.0.2:4000"
node_name = "growth@172.25.0.2"

IO.puts("""
üåê CONECTANDO √Ä APLICA√á√ÉO EM PRODU√á√ÉO:

‚úÖ URL P√∫blica: #{public_url}
üê≥ Container: #{node_name}
üîó URL Interna: #{internal_url}
üöÄ Ambiente: Produ√ß√£o (Docker)
üìä Dados: Reais de usu√°rios reais!

Vamos conectar e observar a telemetria ao vivo!
""")

```

```elixir
IO.puts("üåê Testando acesso p√∫blico...")
case Req.get(public_url) do
  {:ok, %{status: 200}} ->
    IO.puts("‚úÖ Aplica√ß√£o p√∫blica acess√≠vel!")
  {:ok, %{status: status}} ->
    IO.puts("‚ö†Ô∏è Aplica√ß√£o respondeu com status #{status}")
  {:error, reason} ->
    IO.puts("‚ùå Erro de conex√£o p√∫blica: #{inspect(reason)}")
end
```

```elixir
IO.puts("\nüê≥ Testando acesso interno ao container...")
case Req.get(internal_url, receive_timeout: 5000) do
  {:ok, %{status: 200}} ->
    IO.puts("‚úÖ Container acess√≠vel diretamente!")
  {:ok, %{status: status}} ->
    IO.puts("‚ö†Ô∏è Container respondeu com status #{status}")
  {:error, reason} ->
    IO.puts("‚ÑπÔ∏è Acesso interno n√£o dispon√≠vel (normal): #{inspect(reason)}")
    IO.puts("üí° Usando URL p√∫blica para demonstra√ß√£o")
end
```

```elixir
defmodule NodeConnection do
  def try_connect_to_node do
    node_name = :"growth@172.25.0.2"

    IO.puts("üîó TENTANDO CONECTAR AO NODE ERLANG:")
    IO.puts("   Node: #{node_name}")
    IO.puts("   Node local: #{Node.self()}")

    # Verificar se o node est√° acess√≠vel
    case Node.ping(node_name) do
      :pong ->
        IO.puts("‚úÖ Node conectado com sucesso!")

        # Obter informa√ß√µes do sistema remoto
        remote_info = :rpc.call(node_name, :erlang, :system_info, [:system_version])
        IO.puts("üìä Vers√£o do sistema: #{remote_info}")

        # Obter estat√≠sticas de mem√≥ria
        memory_info = :rpc.call(node_name, :erlang, :memory, [])
        IO.puts("üß† Uso de mem√≥ria:")
        Enum.each(memory_info, fn {type, bytes} ->
          mb = Float.round(bytes / (1024 * 1024), 2)
          IO.puts("   #{type}: #{mb}MB")
        end)

        # Obter n√∫mero de processos
        process_count = :rpc.call(node_name, :erlang, :system_info, [:process_count])
        IO.puts("‚öôÔ∏è Processos ativos: #{process_count}")

        {:ok, :connected}

      :pang ->
        IO.puts("‚ÑπÔ∏è Node n√£o acess√≠vel diretamente (normal em produ√ß√£o)")
        IO.puts("üí° Isso √© esperado por quest√µes de seguran√ßa")
        IO.puts("üîÑ Continuando com m√©tricas HTTP...")
        {:error, :not_accessible}
    end
  end

  def get_vm_metrics_simulation do
    IO.puts("üìä SIMULA√á√ÉO DE M√âTRICAS DA VM ERLANG:")
    IO.puts("=" |> String.duplicate(50))
    IO.puts("üê≥ Node: growth@172.25.0.2")
    IO.puts("‚è∞ Timestamp: #{DateTime.utc_now()}")
    IO.puts("")

    # Simular m√©tricas que estariam dispon√≠veis
    simulated_metrics = [
      {"Mem√≥ria Total", "45.6MB"},
      {"Processos", "156"},
      {"Schedulers", "8"},
      {"Uptime", "2d 14h 32m"},
      {"GC Count", "1,234"},
      {"Reductions", "12,345,678"}
    ]

    Enum.each(simulated_metrics, fn {metric, value} ->
      IO.puts("üìà #{metric}: #{value}")
    end)

    IO.puts("\nüí° Em um ambiente com acesso direto ao node, poder√≠amos obter:")
    IO.puts("   - Estat√≠sticas detalhadas de mem√≥ria")
    IO.puts("   - Informa√ß√µes de processos em tempo real")
    IO.puts("   - M√©tricas de garbage collection")
    IO.puts("   - Estado dos schedulers")
    IO.puts("   - Traces distribu√≠dos internos")
  end
end

# Tentar conectar (provavelmente falhar√° por seguran√ßa)
NodeConnection.try_connect_to_node()

# Mostrar simula√ß√£o das m√©tricas que ter√≠amos
IO.puts("")
NodeConnection.get_vm_metrics_simulation()
```

```elixir
defmodule LiveMetrics do
  def fetch_metrics(base_url \\ "https://crescer.dubas.dev") do
    metrics_url = "#{base_url}/metrics"

    case Req.get(metrics_url) do
      {:ok, %{status: 200, body: body}} ->
        {:ok, body}
      {:ok, %{status: status}} ->
        {:error, "HTTP #{status} - M√©tricas podem n√£o estar expostas publicamente"}
      {:error, reason} ->
        {:error, "Conex√£o falhou: #{inspect(reason)}"}
    end
  end

  def parse_metrics(metrics_text) do
    metrics_text
    |> String.split("\n")
    |> Enum.reject(&String.starts_with?(&1, "#"))
    |> Enum.reject(&(&1 == ""))
    |> Enum.take(20)  # Primeiras 20 m√©tricas para n√£o sobrecarregar
  end

  def display_metrics(metrics_lines) do
    IO.puts("üìä M√âTRICAS REAIS DA APLICA√á√ÉO GROWTH (PRODU√á√ÉO)")
    IO.puts("=" |> String.duplicate(60))
    IO.puts("üîó Fonte: https://crescer.dubas.dev/metrics")
    IO.puts("‚è∞ Timestamp: #{DateTime.utc_now()}")
    IO.puts("")

    Enum.with_index(metrics_lines, 1)
    |> Enum.each(fn {line, index} ->
      IO.puts("#{index}. #{line}")
    end)
  end
end

# Buscar m√©tricas reais
case LiveMetrics.fetch_metrics() do
  {:ok, metrics_text} ->
    metrics_text
    |> LiveMetrics.parse_metrics()
    |> LiveMetrics.display_metrics()

  {:error, reason} ->
    IO.puts("‚ùå ERRO: #{reason}")
    IO.puts("üí° Certifique-se de que a aplica√ß√£o est√° rodando em http://localhost:4000")
    IO.puts("   Execute: mix phx.server")
end
```

```elixir
defmodule TrafficGenerator do
  def make_requests(count \\ 5) do
    IO.puts("üöÄ GERANDO #{count} REQUISI√á√ïES...")

    results =
      1..count
      |> Enum.map(fn i ->
        IO.puts("üì° Requisi√ß√£o #{i}/#{count}")

        start_time = System.monotonic_time(:millisecond)

        result = case Req.get("https://crescer.dubas.dev/") do
          {:ok, %{status: status}} ->
            duration = System.monotonic_time(:millisecond) - start_time
            %{status: status, duration: duration, success: true}
          {:error, reason} ->
            duration = System.monotonic_time(:millisecond) - start_time
            %{error: reason, duration: duration, success: false}
        end

        Process.sleep(500)  # Pausa entre requisi√ß√µes
        result
      end)

    # Mostrar resultados
    IO.puts("\nüìà RESULTADOS:")
    Enum.with_index(results, 1)
    |> Enum.each(fn {result, i} ->
      if result.success do
        IO.puts("‚úÖ #{i}. HTTP #{result.status} - #{result.duration}ms")
      else
        IO.puts("‚ùå #{i}. ERRO: #{result.error} - #{result.duration}ms")
      end
    end)

    # Estat√≠sticas
    successful = Enum.count(results, & &1.success)
    total_duration = Enum.sum(Enum.map(results, & &1.duration))
    avg_duration = if count > 0, do: total_duration / count, else: 0

    IO.puts("\nüìä ESTAT√çSTICAS:")
    IO.puts("‚úÖ Sucessos: #{successful}/#{count}")
    IO.puts("‚è±Ô∏è  Dura√ß√£o m√©dia: #{Float.round(avg_duration, 2)}ms")
    IO.puts("üìà Taxa de sucesso: #{Float.round(successful/count*100, 1)}%")

    results
  end
end

# Gerar tr√°fego
TrafficGenerator.make_requests(3)
```

```elixir
# Capturar m√©tricas antes
IO.puts("üìä CAPTURANDO M√âTRICAS ANTES...")
{:ok, metrics_before} = LiveMetrics.fetch_metrics()

# Gerar mais tr√°fego
IO.puts("\nüöÄ GERANDO TR√ÅFEGO...")
TrafficGenerator.make_requests(5)

# Aguardar um pouco para as m√©tricas serem atualizadas
Process.sleep(2000)

# Capturar m√©tricas depois
IO.puts("\nüìä CAPTURANDO M√âTRICAS DEPOIS...")
{:ok, metrics_after} = LiveMetrics.fetch_metrics()
```

```elixir
defmodule MetricsComparison do
  def extract_metric_value(metrics_text, metric_name) do
    metrics_text
    |> String.split("\n")
    |> Enum.find(&String.starts_with?(&1, metric_name))
    |> case do
      nil -> 0
      line ->
        line
        |> String.split(" ")
        |> List.last()
        |> String.to_float()
    end
  end

  def compare_metrics(before, following) do
    metrics_to_compare = [
      "phoenix_http_requests_total",
      "phoenix_endpoint_stop_duration_seconds_count",
      "vm_memory_bytes_total"
    ]

    IO.puts("üîç COMPARA√á√ÉO DE M√âTRICAS:")
    IO.puts("=" |> String.duplicate(50))

    Enum.each(metrics_to_compare, fn metric ->
      before_val = extract_metric_value(before, metric)
      after_val = extract_metric_value(following, metric)
      diff = after_val - before_val

      IO.puts("üìà #{metric}:")
      IO.puts("   Antes: #{before_val}")
      IO.puts("   Depois: #{after_val}")
      IO.puts("   Diferen√ßa: +#{diff}")
      IO.puts("")
    end)
  end
end

MetricsComparison.compare_metrics(metrics_before, metrics_after)
```

```elixir
defmodule GrowthAppSimulator do
  def simulate_child_growth_calculation do
    IO.puts("üë∂ SIMULANDO C√ÅLCULO DE CRESCIMENTO...")

    # Dados de exemplo de uma crian√ßa
    child_data = %{
      name: "Ana",
      gender: "female",
      birthday: "2021-01-01"
    }

    measure_data = %{
      weight: 14.5,
      height: 95.0,
      head_circumference: 48.0
    }

    IO.puts("üìã Dados da crian√ßa:")
    IO.puts("   Nome: #{child_data.name}")
    IO.puts("   G√™nero: #{child_data.gender}")
    IO.puts("   Nascimento: #{child_data.birthday}")

    IO.puts("\nüìè Medidas:")
    IO.puts("   Peso: #{measure_data.weight}kg")
    IO.puts("   Altura: #{measure_data.height}cm")
    IO.puts("   Per√≠metro cef√°lico: #{measure_data.head_circumference}cm")

    # Fazer requisi√ß√£o para a p√°gina principal
    IO.puts("\nüåê Acessando aplica√ß√£o em produ√ß√£o...")

    case Req.get("https://crescer.dubas.dev/") do
      {:ok, %{status: 200}} ->
        IO.puts("‚úÖ Aplica√ß√£o acessada com sucesso!")
        IO.puts("üí° Em uma aplica√ß√£o real, aqui far√≠amos:")
        IO.puts("   1. POST para salvar dados da crian√ßa")
        IO.puts("   2. POST para salvar medidas")
        IO.puts("   3. C√°lculo dos z-scores e percentis")
        IO.puts("   4. Gera√ß√£o dos gr√°ficos de crescimento")

        # Simular m√∫ltiplas requisi√ß√µes para gerar telemetria
        IO.puts("\nüîÑ Simulando fluxo completo...")

        Enum.each(1..3, fn step ->
          IO.puts("   Passo #{step}: Processando...")
          Req.get("http://localhost:4000/")
          Process.sleep(1000)
        end)

        IO.puts("‚úÖ Simula√ß√£o conclu√≠da!")

      {:error, reason} ->
        IO.puts("‚ùå Erro ao acessar aplica√ß√£o: #{inspect(reason)}")
    end
  end
end

GrowthAppSimulator.simulate_child_growth_calculation()
```

```elixir
defmodule LiveLogs do
  def simulate_real_logs do
    IO.puts("üìã LOGS QUE ESTARIAM SENDO GERADOS AGORA:")
    IO.puts("=" |> String.duplicate(60))

    logs = [
      %{
        timestamp: DateTime.utc_now(),
        level: "info",
        message: "GET / - Sent 200",
        metadata: %{
          duration: "45.2ms",
          request_id: "F8mOKAmVmjsAABEh"
        }
      },
      %{
        timestamp: DateTime.utc_now() |> DateTime.add(-2, :second),
        level: "info",
        message: "LiveView connected",
        metadata: %{
          socket_id: "phx-F8mOKAmVmjsAABEh",
          transport: "websocket"
        }
      },
      %{
        timestamp: DateTime.utc_now() |> DateTime.add(-5, :second),
        level: "info",
        message: "CSV data loaded: weight_for_age.csv",
        metadata: %{
          records: 1856,
          duration: "580ms"
        }
      }
    ]

    Enum.each(logs, fn log ->
      level_icon = case log.level do
        "info" -> "‚ÑπÔ∏è"
        "error" -> "üö®"
        "warn" -> "‚ö†Ô∏è"
      end

      IO.puts("#{level_icon} [#{DateTime.to_time(log.timestamp)}] #{log.message}")

      if log.metadata do
        Enum.each(log.metadata, fn {key, value} ->
          IO.puts("    #{key}: #{value}")
        end)
      end

      IO.puts("")
    end)

    IO.puts("üí° Para ver logs reais, execute no terminal:")
    IO.puts("   tail -f _build/dev/lib/growth/ebin/growth.log")
    IO.puts("   ou observe o terminal onde mix phx.server est√° rodando")
  end
end

LiveLogs.simulate_real_logs()
```

```elixir
defmodule LiveDashboard do
  def create_live_dashboard do
    IO.puts("üìä DASHBOARD AO VIVO - APLICA√á√ÉO GROWTH")
    IO.puts("=" |> String.duplicate(50))
    IO.puts("üïê Atualizado em: #{DateTime.utc_now()}")
    IO.puts("")

    # Buscar m√©tricas atuais
    case LiveMetrics.fetch_metrics() do
      {:ok, metrics} ->
        # Extrair m√©tricas espec√≠ficas
        http_requests = extract_counter(metrics, "phoenix_http_requests_total")
        memory_usage = extract_gauge(metrics, "vm_memory_bytes_total")

        IO.puts("üåê HTTP:")
        IO.puts("   üìà Total de requisi√ß√µes: #{http_requests}")

        IO.puts("\nüíª SISTEMA:")
        memory_mb = if memory_usage > 0, do: Float.round(memory_usage / (1024*1024), 1), else: 0
        IO.puts("   üß† Uso de mem√≥ria: #{memory_mb}MB")

        IO.puts("\nüè• STATUS:")
        status = if http_requests > 0, do: "üü¢ ATIVO", else: "üü° AGUARDANDO TR√ÅFEGO"
        IO.puts("   #{status}")

      {:error, reason} ->
        IO.puts("‚ùå N√£o foi poss√≠vel buscar m√©tricas: #{reason}")
        IO.puts("üí° Certifique-se de que a aplica√ß√£o est√° rodando")
    end
  end

  defp extract_counter(metrics, name) do
    metrics
    |> String.split("\n")
    |> Enum.filter(&String.contains?(&1, name))
    |> Enum.reject(&String.starts_with?(&1, "#"))
    |> Enum.map(fn line ->
      line
      |> String.split(" ")
      |> List.last()
      |> parse_number()
    end)
    |> Enum.sum()
    |> trunc()
  end

  defp extract_gauge(metrics, name) do
    metrics
    |> String.split("\n")
    |> Enum.find(&String.starts_with?(&1, name))
    |> case do
      nil -> 0
      line ->
        line
        |> String.split(" ")
        |> List.last()
        |> parse_number()
    end
  end

  defp parse_number(str) do
    cond do
      String.contains?(str, ".") ->
        # √â um float
        case Float.parse(str) do
          {num, _} -> num
          :error -> 0
        end
      true ->
        # √â um inteiro
        case Integer.parse(str) do
          {num, _} -> num
          :error -> 0
        end
    end
  end
end

LiveDashboard.create_live_dashboard()
```

```elixir
IO.puts("üìä DASHBOARD INICIAL:")
LiveDashboard.create_live_dashboard()

IO.puts("\nüí° DICAS PARA DEMONSTRA√á√ÉO:")
IO.puts("1. üåê Acesse https://crescer.dubas.dev em outra aba")
IO.puts("2. üë∂ Preencha dados de uma crian√ßa")
IO.puts("3. üìè Adicione medidas e calcule crescimento")
IO.puts("4. üîÑ Execute a c√©lula abaixo para atualizar dashboard")
IO.puts("5. üìä Observe as m√©tricas mudando em tempo real!")
```

```elixir
IO.puts("üîÑ ATUALIZANDO DASHBOARD...")
IO.puts("‚è∞ #{DateTime.utc_now()}")
IO.puts("")

LiveDashboard.create_live_dashboard()

IO.puts("\nüéØ Execute esta c√©lula quantas vezes quiser para ver mudan√ßas!")
IO.puts("üí° Gere tr√°fego na aplica√ß√£o e execute novamente para ver diferen√ßas")
```

<!-- livebook:{"offset":41683,"stamp":{"token":"XCP.zxaWnWOpyRz79vYci-GFtCU5Lz8ZvejC9DMxvxgmTqaNEv5JPBoBj4TGeX2xsagKMRvYNXOFSrNnmI-rtaiA6PYEweDByQP3pG8wo52xixJnCPcNrkgZjhpV6a-uPxOc1nhzUYFlwUwDLWo8b7F7fbMytwo52hSxoe8woVEA","version":2}} -->
